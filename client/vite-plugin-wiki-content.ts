/**
 * Vite Plugin for Wiki Content Loading
 * 
 * This plugin:
 * 1. Scans the wiki directory for .mdx files
 * 2. Parses frontmatter and content
 * 3. Generates a module that exports all wiki content
 * 4. Enables hot-reload during development
 */

import { Plugin } from 'vite';
import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';

interface WikiPageMetadata {
    title: string;
    titleVariants?: string[];
    category: 'standard' | 'role' | 'modifier' | 'category' | 'generated';
    translatable?: boolean;
    dynamic?: boolean;
    tags?: string[];
}

interface WikiPageContent {
    metadata: WikiPageMetadata;
    content: string;
    rawContent: string;
}

interface WikiFileInfo {
    path: string;
    fullPath: string;
    parsedContent: WikiPageContent;
}

export default function wikiContentPlugin(): Plugin {
    const virtualModuleId = 'virtual:wiki-content';
    const resolvedVirtualModuleId = '\0' + virtualModuleId;
    
    let wikiDir: string;
    let wikiFiles: Map<string, WikiFileInfo> = new Map();

    function scanWikiDirectory(dir: string, baseDir: string = dir): void {
        const entries = fs.readdirSync(dir, { withFileTypes: true });
        
        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);
            
            if (entry.isDirectory()) {
                scanWikiDirectory(fullPath, baseDir);
            } else if (entry.isFile() && (entry.name.endsWith('.mdx') || entry.name.endsWith('.md'))) {
                // Skip README files
                if (entry.name.toUpperCase().startsWith('README')) {
                    continue;
                }
                
                const relativePath = path.relative(baseDir, fullPath);
                const wikiPath = relativePath
                    .replace(/\\/g, '/')
                    .replace(/\.(mdx|md)$/, '');
                
                const rawContent = fs.readFileSync(fullPath, 'utf-8');
                
                // Parse the frontmatter at build time
                const { data, content } = matter(rawContent);
                
                wikiFiles.set(wikiPath, {
                    path: wikiPath,
                    fullPath: fullPath,
                    parsedContent: {
                        metadata: data as WikiPageMetadata,
                        content: content,
                        rawContent: rawContent
                    }
                });
            }
        }
    }

    function generateWikiModule(): string {
        const pages: Record<string, WikiPageContent> = {};
        
        for (const [wikiPath, fileInfo] of wikiFiles) {
            pages[wikiPath] = fileInfo.parsedContent;
        }
        
        return `
// Auto-generated wiki content module
// Do not edit this file directly - it's generated from .mdx files in src/resources/wiki/

const wikiPages = ${JSON.stringify(pages, null, 2)};

export default wikiPages;
        `.trim();
    }

    return {
        name: 'vite-plugin-wiki-content',
        
        configResolved(config) {
            wikiDir = path.resolve(config.root, 'src/resources/wiki');
        },
        
        buildStart() {
            // Scan wiki directory and load all files
            wikiFiles.clear();
            
            if (fs.existsSync(wikiDir)) {
                scanWikiDirectory(wikiDir);
            }
        },
        
        resolveId(id) {
            if (id === virtualModuleId) {
                return resolvedVirtualModuleId;
            }
        },
        
        load(id) {
            if (id === resolvedVirtualModuleId) {
                return generateWikiModule();
            }
        },
        
        handleHotUpdate({ file, server }) {
            // If a wiki file changes, reload the virtual module
            if (file.startsWith(wikiDir)) {
                // Rescan the wiki directory
                wikiFiles.clear();
                scanWikiDirectory(wikiDir);
                
                // Invalidate the virtual module
                const module = server.moduleGraph.getModuleById(resolvedVirtualModuleId);
                if (module) {
                    server.moduleGraph.invalidateModule(module);
                }
                
                // Trigger HMR
                server.ws.send({
                    type: 'full-reload'
                });
                
                return [];
            }
        }
    };
}
